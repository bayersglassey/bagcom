#!/bin/bash
set -euo pipefail

repeat() {
    # Output a string consisting of $1 copies of character $2
    printf "%${1}s" | tr ' ' "$2"
}

# Binaries from my geom2018 repo live here
GEOMDIR="../geom2018/bin"

# Input & output directories of this script
SITE_INDIR="src"
SITE_OUTDIR="dst"

# Keep a newline around in a variable
NL='
'

# Separator token for "code blocks"
BLOCKSEP='```'

# Command which converts .fus to .html (from geom2018 repo)
LEXERTOOL="$GEOMDIR/lexertool"
fus2html() {
    "$LEXERTOOL" -r --html
}

# Directory containing the .fus files used by blocks of type "fusfig"
# (and related directories...)
FUSFIG_DIR="src/figures"
FUSFIG_OUTDIR="fusfig/dst"
FUSFIG_STATIC="figs"
FUSFIG_STATICDIR="$SITE_OUTDIR/$FUSFIG_STATIC"
FUSFIG_EXT="png"

# The minieditor command from geom2018 repo
MINIEDITOR="$GEOMDIR/minieditor"
minieditor() {
    "$MINIEDITOR" --pal fusfig/pal.fus --font fusfig/font.fus --fonts fusfig/fonts.fus "$@"
}
MINIEDITOR_SCREENSHOT="screen.bmp"

# Directories/urls of the files generated by blocks of type "bb"
DEFAULT_BB_T1=100000
BB_CHANNELS=2
BB_OUTDIR="bb/dst"
BB_TMPDIR="bb/tmp"
BB_STATIC="bb"
BB_STATICDIR="$SITE_OUTDIR/$BB_STATIC"
BB_HEADERFILE="bb/header.html"

# Name of the website we're building
SITENAME="bayersglassey.com"

# Set up variables so we can easily print horizontal lines
LINEWIDTH=60
THINLINE="$(repeat "$LINEWIDTH" '-')"
THICKLINE="$(repeat "$LINEWIDTH" '#')"


log_depth=0
log() {
    repeat "$log_depth" "  "
    echo "=== $@" >&2
}

do_with_log() {
    log "Executing: $@"
    "$@"
}

print_thinline() {
    echo "$THINLINE" >&2
}

print_thickline() {
    echo "$THICKLINE" >&2
}

require_cmd() {
    command -v "$1" >/dev/null || {
        log "Missing required command: $1"
        exit 1
    }
}

# Markdown parser command, we feed it Markdown and expect HTML back.
# Currently using `apt install markdown`
require_cmd markdown

# sox for audio format conversion
require_cmd sox

require_cmd "$LEXERTOOL"
require_cmd "$MINIEDITOR"


#############################################################################

copydir() {
    # Why rm -rf "$2" first?.. because cp -r "$1" "$2" will behave differently
    # depending on whether "$2" already exists.
    # If it already exists, cp will put everything *inside* it!..
    # Which is not what we want.
    do_with_log rm -rf "$2"
    do_with_log cp -r "$1" "$2"
}

pageurl() {
    # Usage: pageurl OUTFILE
    PAGEURL_FILENAME="`echo "$1" | sed "s@/root/@/@"`"
    echo "/${PAGEURL_FILENAME#$SITE_OUTDIR/}"
}

htmlescape() {
    # Based on: https://stackoverflow.com/a/12873723
    sed \
        -e 's/&/\&amp;/g' \
        -e 's/</\&lt;/g' \
        -e 's/>/\&gt;/g' \
        -e 's/"/\&quot;/g' \
        -e 's/'"'"'/\&#39;/g'
}

chop() {
    # Usage: chop DATA SEPARATOR
    # Chops DATA into two substrings at the first occurrence of SEPARATOR.
    # The substrings are returned in HEAD and TAIL.
    HEAD="${1%%"$2"*}"
    TAIL="${1#*"$2"}"
}

replace() {
    # Usage: replace STR1 STR2 STRING
    # Replaces first occurrence of STR1 with STR2 in STRING.
    # Returns the result in REPLACED.
    chop "$3" "$1"
    REPLACED="$HEAD$2$TAIL"
}

parseblocks() {
    # Usage: parseblocks DATA
    # Parses DATA, replacing blocks with "{BLOCKxxx}" where xxx is a nonnegative integer.
    # The parsed string is returned in PARSED.
    # The data of each block xxx is stored in corresponding variables BLOCKxxx.
    # The type of each block xxx is stored in corresponding variables BLOCKTYPExxx.
    #
    # Example of a block (in this case, the type is "json"):
    #
    #     ```json
    #     {
    #         "a": 1,
    #         "b": 2
    #     }
    #     ```
    #
    # Example of iterating over the blocks:
    #
    #     for i in `seq "$BLOCKNUM"`
    #     do eval "echo \"Block \$i (\$BLOCKTYPE$i): \$BLOCK$i\""
    #     done
    #

    DATA="$1"
    PARSED=""
    BLOCKNUM=0

    while true
    do
        chop "$DATA" "$BLOCKSEP"
        test "$HEAD" != "$DATA" || break

        # BLOCKNUM was initialized to 0 outside the loop.
        # We increment it here *before* using it, so first blocknum is 1.
        # This is so that we can iterate over it using `seq $BLOCKNUM`.
        BLOCKNUM="`expr "$BLOCKNUM" + 1`"

        HEAD0="$HEAD"
        chop "$TAIL" "$NL"
        TYPE="$HEAD"
        chop "$TAIL" "$NL$BLOCKSEP"
        eval "BLOCK$BLOCKNUM=\"\$HEAD\""
        eval "BLOCKTYPE$BLOCKNUM=\"\$TYPE\""
        PARSED="$PARSED$HEAD0{BLOCK$BLOCKNUM}"
        DATA="$TAIL"
    done

    PARSED="$PARSED$DATA"
}

fusfig() {
    # Generate a figure from an rgraph in a .fus file.
    # Writes an <img> tag for the resulting image to stdout.
    FUSFIG_TYPE="$1"
    FUSFIG_FILENAME="$2"
    FUSFIG_RGRAPH="$3"
    shift 3

    FUSFIG_INFILE="$FUSFIG_DIR/$FUSFIG_FILENAME"
    FUSFIG_OUTSUBDIR="$FUSFIG_OUTDIR/${FUSFIG_FILENAME%.fus}"
    do_with_log mkdir -p "$FUSFIG_OUTSUBDIR"
    FUSFIG_OUTFILE="$FUSFIG_OUTSUBDIR/$FUSFIG_RGRAPH.$FUSFIG_EXT"
    FUSFIG_STATICFILE="/$FUSFIG_STATIC/${FUSFIG_FILENAME%.fus}/$FUSFIG_RGRAPH.$FUSFIG_EXT"

    log "Building fus figure: $FUSFIG_OUTFILE"
    do_with_log minieditor -f "$FUSFIG_INFILE" -n "$FUSFIG_RGRAPH" "$@" -q --nocontrols --screenshot
    do_with_log convert "$MINIEDITOR_SCREENSHOT" "$FUSFIG_OUTFILE"

    FUSFIG_FILENAME_OUTFILE_RAW="$SITE_OUTDIR/${FUSFIG_INFILE#$SITE_INDIR/}"
    FUSFIG_FILENAME_OUTFILE="${FUSFIG_FILENAME_OUTFILE_RAW%.*}.html"
    FUSFIG_FILENAME_OUTFILE_URL="`pageurl "$FUSFIG_FILENAME_OUTFILE"`"

    # Ganky "extensions" to the fusfig block type...
    case "$FUSFIG_TYPE" in
    *header*)
        echo "<h4><i>$FUSFIG_RGRAPH</i> (defined in <a href=\"$FUSFIG_FILENAME_OUTFILE_URL\">$FUSFIG_FILENAME</a>)</h4>"
    esac

    echo "<img src=\"$FUSFIG_STATICFILE\">"
}


get_projects() {
    find "$SITE_INDIR" -mindepth 1 -maxdepth 1 -type d | sed "s@^$SITE_INDIR/@@"
}


SKIP_PROJECTS="${SKIP_PROJECTS-bytebeats}"
if test "$#" = 0
then
    BUILD_ALL=true
    PROJECTS="$(get_projects)"
    for skip_project in $SKIP_PROJECTS
    do
        PROJECTS="$(printf %s "$PROJECTS" | grep -v "$skip_project")"
    done
    PROJECTS="$(printf %s "$PROJECTS" | tr '\n' ' ')"
elif test "$1" = "-h" -o "$1" = "--help"
then
    log "Usage: build.sh [PROJECT ...]"
    log "If no projects supplied, all will be built, except skipped ones."
    log "When building all projects in that way, certain directories will be "
    log "deleted & recreated from scratch."
    log "Here are all projects: $(get_projects | tr '\n' ' ')"
    log "Here are projects skipped by default: $SKIP_PROJECTS"
    log "In order to build all projects, but not skip any, set the SKIP_PROJECTS"
    log "env var to the empty string: SKIP_PROJECTS= ./build.sh"
    exit 0
else
    BUILD_ALL=false
    PROJECTS="$@"
fi

# And so it begins.
print_thickline
log "Building projects: $PROJECTS"
log "Skipped projects: $SKIP_PROJECTS"
log "Source directory: $SITE_INDIR"
log "Output directory: $SITE_OUTDIR"

# Create output directories
if test "$BUILD_ALL" = true
then
    do_with_log rm -rf "$SITE_OUTDIR"
    do_with_log rm -rf "$FUSFIG_OUTDIR"
    do_with_log rm -rf "$BB_OUTDIR"
fi
do_with_log mkdir -p "$SITE_OUTDIR"
do_with_log mkdir -p "$FUSFIG_OUTDIR"
do_with_log mkdir -p "$BB_OUTDIR"
do_with_log rm -rf "$BB_TMPDIR"
do_with_log mkdir -p "$BB_TMPDIR"

# Slurp header & footer HTML
HEADERFILE="$SITE_INDIR/header.html"
FOOTERFILE="$SITE_INDIR/footer.html"
HEADER="`cat $HEADERFILE`"
FOOTER="`cat $FOOTERFILE`"
# (Warning: command expansion removes trailing newlines!.. so $HEADER and
# $FOOTER won't have trailing newlines, even if the contents of $HEADERFILE
# and/or $FOOTERFILE do.)

HEADER="$HEADER$NL`cat "$BB_HEADERFILE"`"


bagcom_builddir() {
    ACTION="$1"
    INDIR="$2"

    OUTDIR="$SITE_OUTDIR/${INDIR#$SITE_INDIR/}"

    # $DIRCONFIGFILE: a file containing metadata about the pages in
    # $INDIR (for instance, about their "parent" page)
    DIRCONFIGFILE="$INDIR/dir.config"

    print_thinline
    log "Building dir (action=$ACTION): $INDIR -> $OUTDIR"

    # Variables which can be set by $DIRCONFIGFILE
    PARENTNAME=""
    PARENTURL=""

    # ...ok, set the variables please
    if test -f "$DIRCONFIGFILE"
    then
        log "Using dirconfig file: $DIRCONFIGFILE"
        . "$DIRCONFIGFILE"
    else
        log "...skipping missing dirconfig file: $DIRCONFIGFILE"
    fi

    log "PARENTNAME=$PARENTNAME"
    log "PARENTURL=$PARENTURL"

    if test "$ACTION" = "list"
    then
        # Create output directory
        do_with_log mkdir -p "$OUTDIR"

        # Copy static assets (if present)
        test ! -d "$INDIR/img" || copydir "$INDIR/img" "$OUTDIR/img"
    fi

    : $(( log_depth++ ))
    for INFILE in "$INDIR"/*
    do
        BASENAME="`basename -- "$INFILE"`"
        EXT="${BASENAME##*.}"

        # Only process files with these extensions
        test "$EXT" = "txt" -o "$EXT" = "html" -o "$EXT" = "md" -o "$EXT" = "fus" || continue

        OUTFILE_RAW="$SITE_OUTDIR/${INFILE#$SITE_INDIR/}"
        OUTFILE="${OUTFILE_RAW%.*}.html"
        OUTFILE_RAW_URL="`pageurl "$OUTFILE_RAW"`"

        print_thinline
        log "Processing file (action=$ACTION): $INFILE -> $OUTFILE"

        # $CONFIGFILE: a file containing metadata about the page whose
        # contents are in $INFILE
        CONFIGFILE="$INFILE.config"

        # Variables which can be set by $CONFIGFILE
        TITLE="${BASENAME/.*}"
        CHILDPAGES_DIR=""

        # ...ok, set the variables please
        if test -f "$CONFIGFILE"
        then
            log "Using config file: $CONFIGFILE"
            . "$CONFIGFILE"
        else
            log "...skipping missing config file: $CONFIGFILE"
        fi

        log "TITLE=$TITLE"
        log "CHILDPAGES_DIR=$CHILDPAGES_DIR"

        case "$ACTION" in
            list)
                log "Listing: $INFILE"
                log "Output: $OUTFILE"

                # Touch the file so it can be found when generating
                # CHILDPAGES
                do_with_log touch "$OUTFILE"

                # Store the title somewhere we can find it when
                # generating CHILDPAGES
                echo "$TITLE" >"$OUTFILE.title"
            ;;
            build)
                log "Building: $INFILE"
                log "Output: $OUTFILE"
                bagcom_buildfile
                log "Done!"
            ;;
            *)
                log "Unrecognized action: $ACTION"
                exit 1
            ;;
        esac
    done
    : $(( log_depth-- ))
}

bagcom_buildfile() {
    log "Building file: $OUTFILE..."

    # NOTE: We use "@" as the separator in sed's "s" operator, which means
    # we can't use that character in a page's title!
    PROCESSED_HEADER="`echo "$HEADER" | sed \
        -e "s@{TITLE}@$TITLE@" \
        -e "s@{SITENAME}@$SITENAME@" \
        -e "s@{PARENTNAME}@$PARENTNAME@" \
        -e "s@{PARENTURL}@$PARENTURL@" \
    `"

    if test "$OUTFILE_RAW" != "$OUTFILE"
    then
        PROCESSED_HEADER="`echo "$PROCESSED_HEADER" | sed \
            -e "s@{RAWFILE}@$OUTFILE_RAW_URL@" \
        `"
    else
        # Remove (with sed's "d" command) lines which contain "{RAWFILE}"
        PROCESSED_HEADER="`echo "$PROCESSED_HEADER" | sed '/{RAWFILE}/d'`"
    fi

    # Remove any unneeded (according to this page's .config file)
    # breadcrumbs from header
    if test "$PARENTURL" = "/"
    then
        # Remove (with sed's "d" command) lines which start with "{CRUMB2}"
        log "*** REMOVING CRUMB2!"
        PROCESSED_HEADER="`echo "$PROCESSED_HEADER" | sed '/^{CRUMB2}/d'`"
    fi
    if test "$OUTFILE" = "dst/root/index.html"
    then
        # Remove (with sed's "d" command) lines which start with "{CRUMB1}"
        log "*** REMOVING CRUMB1!"
        PROCESSED_HEADER="`echo "$PROCESSED_HEADER" | sed '/^{CRUMB1}/d'`"
    fi

    # Remove "{CRUMB1}", "{CRUMB2}" markers
    PROCESSED_HEADER="`echo "$PROCESSED_HEADER" | sed 's/{CRUMB[12]}//'`"

    # Slurp page contents
    BODY="`cat "$INFILE"`"

    # Parse blocks, removing them from BODY.
    # We will put them back in after BODY has been otherwise processed.
    # This lets us implement e.g. custom syntax highlighting in
    # Markdown pages: after BODY is processed as Markdown into HTML, we
    # will put the processed blocks back in.
    log "Parsing blocks..."
    parseblocks "$BODY"
    BODY="$PARSED"
    log "Parsed $BLOCKNUM blocks!"

    # Wrap the contents of .txt files in <pre>
    if test "$EXT" = "txt"
    then
        BODY="<pre>$BODY</pre>"
    fi

    # Process .md files as markdown
    # (Will fail, obviously, if you don't have a markdown parser installed)
    if test "$EXT" = "md"
    then
        BODY="`echo "$BODY" | markdown`"
    fi

    # Process .fus files
    if test "$EXT" = "fus"
    then
        BODY="<pre class=\"fus\">`echo "$BODY" | fus2html`</pre>"
    fi

    # Automatically generate lists of child pages (as directed by the
    # config file)
    if test -n "$CHILDPAGES_DIR"
    then
        BODY="$BODY$NL<ul>$NL"
        for CHILDPAGE_FILE in "$SITE_OUTDIR/$CHILDPAGES_DIR"/*.html
        do
            CHILDPAGE_BASENAME="`basename -- "$CHILDPAGE_FILE"`"
            CHILDPAGE_URL="`pageurl "$CHILDPAGE_FILE"`"
            CHILDPAGE_TITLE="`cat "$CHILDPAGE_FILE.title"`"
            BODY="$BODY<li><a href=\"$CHILDPAGE_URL\">$CHILDPAGE_TITLE</a>$NL"
        done
        BODY="$BODY</ul>"
    fi

    # Put blocks back in, possibly processing them first.
    for i in `seq "$BLOCKNUM"`
    do
        eval "TYPE=\$BLOCKTYPE$i"
        eval "BLOCK=\$BLOCK$i"
        log "Writing block $i (type=$TYPE)..."
        case "$TYPE" in
            fus)
                BLOCK="<pre class=\"fus\">`echo "$BLOCK" | fus2html`</pre>"
            ;;
            fusfig*)
                BLOCK="`fusfig "$TYPE" $BLOCK`"
            ;;
            bb*)
                t0=0
                t1="$DEFAULT_BB_T1"
                chans=2
                audio=true
                inline_svg=false
                read TYPE BB_NAME BB_OPTIONS < <(printf '%s\n' "$TYPE")
                for opt in $BB_OPTIONS
                do
                    case "$opt" in
                        t0=*) t0="${opt##*=}";;
                        t1=*) t1="${opt##*=}";;
                        chans=*) chans="${opt##*=}";;
                        no-audio) audio=false;;
                        inline-svg) inline_svg=true;;
                        *) log "Unrecognized bb option: $opt"; exit 1;;
                    esac
                done

                BB_CFILE="$BB_OUTDIR/$BB_NAME.c"
                BB_WAVFILE="$BB_OUTDIR/$BB_NAME.wav"
                BB_SVGHTMLFILE="$BB_OUTDIR/$BB_NAME.svg.html"
                BB_SVGHTMLINLINEFILE="$BB_OUTDIR/$BB_NAME.svg-inline.html"
                BB_BINFILE="$BB_TMPDIR/$BB_NAME"
                BB_RAWFILE="$BB_TMPDIR/$BB_NAME.raw"
                ! test -f "$BB_BINFILE" || {
                    log "File $BB_BINFILE already exists... each bb block needs a unique name!"
                    exit 1
                }
                log "Generating files for bytebeat: $BB_NAME ($chans channels, sample frames $t0 - $t1)..."
                log "...generating $BB_CFILE, $BB_BINFILE"
                echo "$BLOCK" | do_with_log bb/compile.sh "$BB_CFILE" "$BB_BINFILE" "$chans"
                log "...generating $BB_RAWFILE"
                do_with_log "$BB_BINFILE" "t0=$t0" "t1=$t1" >"$BB_RAWFILE"
                log "...generating $BB_WAVFILE"
                do_with_log sox -t raw -b 8 -r 8000 -c "$chans" -e unsigned-integer "$BB_RAWFILE" "$BB_WAVFILE"
                log "...generating $BB_SVGHTMLFILE"
                do_with_log "$BB_BINFILE" "t0=$t0" "t1=$t1" "mode=S" >"$BB_SVGHTMLFILE"
                log "...OK!"
                BB_CODE_BLOCK="<pre class=\"block-$TYPE bb-pre\">`echo "$BLOCK" | htmlescape`</pre>"
                BLOCK=""
                if test "$audio" = true
                then
                    BLOCK="$BLOCK$NL<div><audio controls src=\"/$BB_STATIC/$BB_NAME.wav\"></audio></div>"
                fi
                BLOCK="$BLOCK$NL$BB_CODE_BLOCK"
                BLOCK="$BLOCK$NL<div class=\"bb-links\">
                    <a href=\"$BB_STATIC/$BB_NAME.c\">$BB_NAME.c</a>
                    <a href=\"$BB_STATIC/$BB_NAME.wav\">$BB_NAME.wav</a>
                    <a href=\"$BB_STATIC/$BB_NAME.svg.html\">$BB_NAME.svg.html</a>
                </div>"
                if test "$inline_svg" = true
                then
                    BLOCK="$BLOCK$NL`do_with_log "$BB_BINFILE" "t0=$t0" "t1=$t1" "mode=s"`"
                fi
            ;;
            *)
                BLOCK="<pre class=\"block-$TYPE\">`echo "$BLOCK" | htmlescape`</pre>"
            ;;
        esac
        replace "{BLOCK$i}" "$BLOCK" "$BODY"
        BODY="$REPLACED"
    done

    # Copy the raw input file over, so OUTFILE can include a link to it
    # (But don't do it if INFILE is already .html, that is, if OUTFILE and
    # OUTFILE_RAW are the same.)
    if test "$OUTFILE_RAW" != "$OUTFILE"
    then
        do_with_log cp "$INFILE" "$OUTFILE_RAW"
    fi

    # Note the $NL (newlines), which we have to add manually, since
    # $HEADER/$FOOTER/$BODY all got their contents from commend expansion,
    # which removes trailing newlines (which is obnoxious).
    log "Writing to $OUTFILE..."
    echo -n "$PROCESSED_HEADER$NL$BODY$NL$FOOTER" >"$OUTFILE"
}


# "List" (touch) output files, so we can automatically generate lists
# of them in the HTML content of files which use CHILDPAGES_DIR
print_thickline
log "Listing files..."
for PROJECT in $PROJECTS
do
    INDIR="$SITE_INDIR/$PROJECT"
    : $(( log_depth++ ))
    bagcom_builddir list "${INDIR%/}"
    : $(( log_depth-- ))
done

# Actually build (generate the content of) the output files
print_thickline
log "Building files..."
for PROJECT in $PROJECTS
do
    INDIR="$SITE_INDIR/$PROJECT"
    : $(( log_depth++ ))
    bagcom_builddir build "${INDIR%/}"
    : $(( log_depth-- ))
done

print_thickline
log "Finishing up..."

# Move files from "root" subdirectory to the actual build output root
do_with_log mv "$SITE_OUTDIR/root"/* "$SITE_OUTDIR/"
do_with_log rmdir "$SITE_OUTDIR/root"

# Copy static assets
copydir img/ "$SITE_OUTDIR/img/"
copydir "$FUSFIG_OUTDIR/" "$FUSFIG_STATICDIR/"
copydir "$BB_OUTDIR/" "$BB_STATICDIR/"
copydir style/ "$SITE_OUTDIR/style/"
copydir scripts/ "$SITE_OUTDIR/scripts/"

# Copy the tape game :O
copy_tape_game() (
    src="$1"
    dst="$2"
    rm -rf "$dst"
    mkdir "$dst"
    cp -r "$src"/*.html "$src"/*.css "$src"/*.js "$dst"/
)
copy_tape_game ../tape_game/ "$SITE_OUTDIR/tape_game"

# Doooone!
print_thickline
log "Build complete!"
log "Source directory: $SITE_INDIR"
log "Output directory: $SITE_OUTDIR"
